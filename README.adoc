// Copyright (c) 2017 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
:projectid: security-intro
:page-layout: guide
:page-duration: 30 minutes
:page-releasedate: 2018-08-11
:page-description: Learn how to secure a web application through authentication and authorization.
:page-tags: ['REST', 'MicroProfile', 'Security', 'CDI']
:page-related-guides: ['microprofile-jwt', 'cdi-intro']
:page-permalink: /guides/{projectid}
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Securing a web application

Learn how to secure a web application through authentication and authorization.

// =================================================================================================
// What you'll learn
// =================================================================================================

== What you'll learn
You will learn how to secure a web application by performing authentication and authorization using the Security feature in the Java EE 8 specification.

Authentication confirms the identity of the user by verifying a user name and password. While authorization determines whether a user has access to a specific servlet.

The security feature in Java EE provides capability to configure the basic, form or custom form authentication mechanism using annotations in the servlet.
It also provides a SecurityContext API for programmatic security checks for both web and enterprise beans resources.

You will learn how to implement form authentication. While basic authentication is only a pop up window for users to fill in their names and password, form authentication provides
an editable form for users to fill in and submit in order to log in to the system. Form authentication is more common and user-friendly in real life applications.

You will also learn how to assign permissions to different roles. This application specifies two roles: Administrator and User.

The application itself will allow users and admins to access pages.
The `user` page and `admin` pages display user information. Both pages will show the name of the currently authenticated user and the admin page will also show the role of the user.

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]


=== Try what you'll build

The  `finish` directory in the root of this guide contains the finished security application with form authentication. Feel free to give it a try before you proceed.

To try out the application, first navigate to the `finish` directory and then run the following Maven goals to build the application and run it inside Open Liberty:

```
mvn install liberty:start-server
```

Next, point your browser to:
// Use https://localhost:9091/ when ServletSecurity.TransportGuarantee.CONFIDENTIAL is enabled in 18003!!!!
`http://localhost:9080`
As you can see, the browser gets redirected from `http` to an `https` link automatically, this is accomplished through the transport guarantee that will be mentioned later on in the guide.

The Identity Store is provided with the following user information credentials:

[#identitystoretable]
.Identity Store
|===
|Username |Password|Role |Group

|alice
|alicepwd
|user
|Employee

|bob
|bobpwd
|admin, user
|Manager, Employee

|carl
|carlpwd
|admin, user
|TeamLead, Employee

|david
|davidpwd
|
|PartTime
|===

You can access the application pages by signing in to the `Home Servlet` with one of the credentials from the Identity Store . 

Notice that when you sign in as Bob or Carl, the browser redirects to the `admin` page and you can view their names as well as their role as `admin`.
When you sign in as Alice, you can only view Alice's name. Furthermore, there is a person named David that belongs to a group called `PartTime` but has no role. 
When you sign in as David, you will be blocked and a message will display `Error 403: AuthorizationFailed`.

Once you are done checking out the application, stop the Open Liberty server:
```
mvn liberty:stop-server
```



// =================================================================================================
//
// =================================================================================================
== Configuring the Identity Store

Navigate to the  `start` directory to begin.

You need to set up the Identity Store to define users and group information. Identity Stores store user account information, such as user name and password, that can be accessed during authentication.
Typically, applications would use an external registry that could be configured with Lightweight Directory Access Protocol (LDAP). However, we will be using `Basic User Registry` as a simple example of an identity store for the purposes of this guide.

To do this, add the following configurations into the `src/main/liberty/config/server.xml` file:

[source, xml, indent=0]
----
include::finish/src/main/liberty/config/server.xml[tags=security]
----

On the Open Liberty server, you can use a `Basic User Registry` as an identity store, to define the users and groups information.
In real life, you will probably connect to a database that stores the user account information.

When you set up the `Basic User Registry for authentication, the names for the users and groups must be unique.

In this application, there are four groups: `Employee`, `TeamLead`, `Manager` and `PartTime`. Groups can be assigned to different access roles.
Within the `<application-bnd>` tags, two different authorization roles are assigned to these groups: `admin` and `user`.

A role can be mapped to a user, a group, or a special subject. The two types of special subject are `EVERYONE` and `ALL_AUTHENTICATED_USERS`.
When a role is mapped to the `EVERYONE` special subject, there is no security because everyone is allowed access and you are not prompted to enter credentials.
When a role is mapped to the `ALL_AUTHENTICATED_USERS` special subject, then any user who is authenticated by the application server can access the protected resource.

=== Encrypting passwords using securityUtility

You need to encrypt the passwords so that they will not appear as plain text in the `server.xml` file, or, in the database in real life.
It mainly protects user credentials from internal attacks, such as information leaking from the inside of an organization.

The passwords assigned to the accounts in identity store is encoded with Liberty's `securityUtility` command. The `securityUtility` is a command that supports plain text encryption and SSL certificate creation for Liberty.

Navigate to `liberty/wlp/bin` in the Liberty server source code you downloaded, and run the following if you have a macOS/Linux machine:
```
./securityUtility encode --encoding=xor alicepwd

```

Here, `alice` and `carl` use the XOR encoding for their passwords. While `bob` uses Advanced Encryption Standard (AES) encryption.
You need to specify a key string to be used when you encode using AES encryption. This string is hashed to produce an encryption key that is used to encrypt and decrypt the password.
The key string is provided from the `bootstrapProperties` in the `pom.xml` file.

```
./securityUtility encode --encoding=aes --key=mykey bobpwd
```

The encryption key can be provided to the server by defining the variable `wlp.password.encryption.key` and setting the value to the key. 
Setting this variable, overrides the default key that is generated. This property is set in a configuration file that should only contain this single property declaration. 
The configuration file itself is saved outside of the configuration directory for the server, this ensures that the file containing your key is not included when running the the server dump or package command.
In this application, the configuration file is saved under `src/main/liberty/config` as `pwdEncryptionKey.xml`.

// =================================================================================================
//
// =================================================================================================

== Implementing authentication

Form Authentication is an authentication mechanism where the user is able to fill in their login credentials using a form that the developers create.
Java EE provides a more convenient way to authenticate a user by calling the built-in `j_security_check` action from the login form.
The `welcome.html` and `error.html` pages are provided for you under the `src/main/webapp` directory. These are two frontend files that provide the login form and error page.

In order to enable form authentication, create the `HomeServlet` class in the `src/main/java/io/openliberty/guides/ui/HomeServlet.java` file.
[source, java, indent=0]
----
include::finish/src/main/java/io/openliberty/guides/ui/HomeServlet.java[tags=homeservlet;!copyright]
----

Notice the `@FormAuthenticationMechanismDefinition` annotation in the class. 
The `@LoginToContinue` annotation allows the application to add specific login functionality to the `AuthenticationMechanism`.
The annotation links the two pages that are required for the form authentication mechanism. The pages are the `errorPage` and the `loginPage`.

At this point, your application is secured using form authentication.

// =================================================================================================
//
// =================================================================================================

== Adding authorization

Authorization determines whether a user has the role required to access to whichever secondary page the `HomeServlet` will redirect them to.

Authorization can be achieved with the `@ServletSecurity` annotation.
Open the `src/main/java/io/openliberty/guides/ui/UserServlet.java` file:

[source, java, indent=0]
----
include::finish/src/main/java/io/openliberty/guides/ui/UserServlet.java[tags=security;!copyright]
----

Note the `@HttpConstraint` annotation, it defines all the security constraints for each servlet resource.
The `admin` and `user` are roles you defined in the `server.xml` configuration file. They are declared under `rolesAllowed` so that the profile can be accessed by authenticated accounts with these two roles.

The transport guarantee defines the data protection requirements that must be satisfied by the transport. In this case, the transport guarantee is set to the `CONFIDENTIAL` configuration which specifies that all user data must be encrypted during transport. 
This ensures that the browser gets redirected from `http` to an `https` link automatically.
The Security specification also defines a common SecurityContext API that can be used to perform some common programmatic security related operations.
You can get access to the information of the authenticated account by calling the appropriate methods from the `SecurityContext` API.

The method `securityContext.isCallerInRole(Utils.ADMIN)` returns a boolean that indicates if the current authenticated account is an `admin` or not.
The method `securityContext.isCallerInRole(Utils.USER)` returns a boolean that indicates if the current authenticated account is an `user` or not.

Open the `src/main/webapp/WEB-INF/web.xml` file:
[source, java, indent=0]
----
include::finish/src/main/webapp/WEB-INF/web.xml[tags=security;!copyright]
----

Note the `security-constraint` that is specified for the `admin` and `user` pages. 
Since these pages are `Java Server Faces`, their security constraint is define in the `src/main/webapp/WEB-INF/web.xml` file.

// =================================================================================================
// Building and running the application
// =================================================================================================

include::{common-includes}/mvnbuild.adoc[]

// Use https://localhost:9091/ when ServletSecurity.TransportGuarantee.CONFIDENTIAL is enabled in 18003!!!!
Use the `http://localhost:9080/` endpoint to choose the information you want to see.

Use one of the credentials from the <<identitystore>> to log in.

// =================================================================================================
// Testing the application
// =================================================================================================

== Testing the application

Now you can write the `SecurityTest` class to test that you can access different servlets with form authentication and authorization.

Create a test class in the `src/test/java/it/io/openliberty/guides/security/SecurityTest.java` file like the following:

[source, java, indent=0]
----
include::finish/src/test/java/it/io/openliberty/guides/security/SecurityTest.java[tags=test]
----

There are four test cases. The `testAuthenticationFail()` case tests a invalid user authentication,
while the `testAuthorizationFail()` case tests a user that exists in the Identity Store but is not authorized to access the application.

The `testAuthorizationForAdmin()` and `testAuthorizationForUser()` cases verify
that only administrator account such as bob can access the `admin` page. However, a normal user like alice can only access the `user` page.

The `executeURL()` method contains the main logic of testing form authentication.

First, the method uses an HttpClient to execute the URL that is passed in by HTTP. After hitting this URL, the response should return the login page.
Next, we use Java EE's `j_security_check`, as mentioned above, to login. If the test was meant to fail, the method checks whether or not the response page is the error page. 
Otherwise, the method executes the redirected URL and checks the contents of the redirected response to see if they match the correct `admin` or `user` page.

include::{common-includes}/mvnverify.adoc[]

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.security.SecurityTest
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.78 sec - in it.io.openliberty.guides.security.SecurityTest

Results :

Tests run: 4, Failures: 0, Errors: 0, Skipped: 0

----

To see whether the tests detect a failure, you can change some input arguments in any of the test cases.
Rerun the Maven build. You see that a test failure occurs.


// =================================================================================================
// Great work! You're done!
// =================================================================================================

== Great work! You're done!

You learned how to use Java EE Security feature to authenticate and authorize users to secure your web application.

Next, you can try the related MicroProfile-JWT guide. It demonstrates technologies to secure backend services and expand on what you built here.


include::{common-includes}/finish.adoc[]
